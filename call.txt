1. recurse(i-1)
        movl    8(%ebp), %eax   # Loads local var i into %eax
        subl    $1, %eax	# i - 1
        movl    %eax, (%esp)    # Pushes i-1 on stack
        call    recur	        # Calls recur(i-1)  
2. ELF and x86
3. .text contains executable code, .data contains uninitialized/initialized words 
4. .symtab is the symbol table -- these are all the symbols that the object file references or defines.
5. Symbol table has 3 entries that have ndx = UND. This means these symbols aren’t defined in the local object file and must be resolved later
6. Symbol table has more entries! The linker combined together the symbol tables of recurse, map, and any shared libraries. We also notice that recurse is resolved. Malloc isn’t resolved since it’s dynamically linked instead. For more info, do readelf -r  map.out. 
7. OS uses the ELF entry point.
8. PT_LOAD, tells OS whether to load segment or not into memory. Any of these will do: .interp, .note, .ABI-tag, .note, .gnu.build-id, .gnu.hash, .dynsym, .dynstr, .gnu.version, .gnu.version_r, .rel.dyn, .rel.plt, .init, .plt, .text, .fini, .rodata, .eh_frame_hdr, .eh_frame, .init_array, .fini_array, .jcr, .dynamic, .got, .got.plt, .data, .bss

